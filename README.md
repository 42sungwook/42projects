# minihell

parsing 참조: https://pubs.opengroup.org/onlinepubs/009604499/utilities/xcu_chap02.html


<details>
<summary>토큰 부여의 11가지 규칙</summary>
1. 입력의 끝이 인식되면 현재 토큰이 구분됩니다. 현재 토큰이 없으면 입력 종료 표시기가 토큰으로 반환됩니다.

2. 이전 문자가 연산자의 일부로 사용되었고 현재 문자가 quote로 감싸져있지 않고 현재 문자와 함께 사용되어 연산자를 형성할 수 있는 경우 해당 (연산자) 토큰의 일부로 사용됩니다.

3. 이전 문자가 연산자의 일부로 사용되었고 현재 문자를 현재 문자와 함께 사용하여 연산자를 구성할 수 없는 경우 이전 문자를 포함하는 연산자는 구분되어야 합니다.

4. 현재 문자가 백슬래시, 작은따옴표 또는 큰따옴표( '\', '" 또는 ' )'이고 인용되지 않은 경우 인용된 텍스트의 끝까지 후속 문자에 대한 인용에 영향을 미칩니다. 
  인용에 대한 규칙은 인용에 설명되어 있습니다.토큰 인식 중에는 실제로 대체가 수행되지 않으며 결과 토큰에는 삽입되거나 둘러싸는 인용 부호를 포함하여 수정되지 않은 
  입력에 나타나는 문자가 정확하게 포함되어야 합니다(<newline> 조인 제외). 또는 인용 부호와 인용된 텍스트의 끝 사이에 있는 대체 연산자 토큰은 인용된 필드의 끝으로 구분되지 않습니다.

-> minishell 과제에서는 구현을 요구하지 않음


5. 현재 문자가 quote로 감싸져있지 않고 '$' 또는 '`'인 경우 쉘은 매개변수 확장( Parameter Expansion), 명령 대체( Command Substitution) 또는 산술 확장( Arithmetic Expansion)에
  대한 후보의 시작을 인용되지 않은 소개에서 식별해야 합니다. 문자 시퀀스: '$' 또는 "${", "$(" 또는 '`' 및 "$((" 각각. 쉘은 확장할 단위의 끝을 결정하기에 충분한 입력을 읽어야 합니다.
  문자를 처리하는 동안 대체 내에 중첩된 확장 또는 인용 인스턴스가 발견되면 쉘은 발견된 구성에 대해 지정된 방식으로 이를 재귀적으로 처리합니다. 포함된 구문을 인식하는 데 필요한 모든 재귀를 
  허용하는 그 끝은 포함되거나 둘러싸는 대체 연산자 또는 따옴표를 포함하여 결과 토큰에 수정되지 않은 상태로 포함되어야 합니다. 토큰은 대체의 끝으로 구분되지 않습니다.

6. 현재 문자가 quote로 감싸져있지 않고 새 연산자의 첫 번째 문자로 사용될 수 있는 경우 현재 토큰(있는 경우)이 구분됩니다. 현재 문자는 다음(연산자) 토큰의 시작으로 사용됩니다.

7. 현재 문자가 quote로 감싸져있지 않고 <newline>이면 현재 토큰이 구분됩니다.

8. 현재 문자가 quote로 감싸져있지 않고 <blank>인 경우 이전 문자를 포함하는 모든 토큰이 구분되고 현재 문자는 삭제됩니다.

9. 이전 문자가 단어의 일부인 경우 현재 문자가 해당 단어에 추가됩니다.

10. 현재 문자가 '#'이면 다음 <newline>까지의 모든 후속 문자는 주석으로 폐기됩니다. 줄을 끝내는 <newline>은 주석의 일부로 간주되지 않습니다.

11. 현재 문자는 새 단어의 시작으로 사용됩니다.
</details>

<details>
<summary>과제에 맞게 변형된 11가지 규칙</summary>
</br>
- 규칙 적용은 한 캐릭터씩 (1 charator) 그리고 규칙의 순서대로 확인합니다. 현재는 ***input** 으로 만들어져있습니다. 1 char를 읽으면서 word로 임시 저장되어질 예정입니다.
</br>
</br>

1. 현재 들어온 캐릭터가 개행일때 (*input == \n)
	- 의미 : **readline**은 문장으로 데이터를 받기 때문에 개행의 의미는 토큰화의 끝을 의미합니다.
<br>
<br>

2. **새로운 단어(word)** 의 첫번째 character가 지정되지 않았으면서 숫자와 리다이렉션의 조합일때
	```
		2<  1< etc.. 
		asd2< 는 앞의 'asd2'가 단어로 인식됨
	```
	- 의미 : 새로운 단어가 만들어지고 있는데 앞에 숫자(fd)가 함께 있는 리다이렉션 조합이면 핸들링 합니다.
<br>
<br>

3. 현재 문자(***input**)가 ' 이거나 " 일때
	- quote state, double-qoute state 등으로 상태 체크를 위한 state 변수들이 필요합니다.
	- 의미 : 이 경우 다음 문자까지가 하나의 문자열(string)으로 인식되어야 합니다. 예를 들어, 'Hello, world!'나 "Hello, world!"와 같은 문자열이 여기에 해당됩니다. 이 규칙은 따옴표로 묶인 문자열과 escape character를 구분하는 역할을 합니다.
<br>
<br>

4.	현재 문자(***input**)가 unqouted state이면서 현재 문자가 $ 이거나  ` 일떄
	- expension state 를 둬서 상태 저장이 필요합니다.
	- 의미 : 이 경우 해당 문자 다음에 오는 문자열은 변수명이나 커맨드라인 명령어로 해석되어야 합니다.
	```
		output=`ls`
		echo $output
	```
	ls 명령어의 결과가 output 변수에 저장되고, echo 명령어로 출력할 수 있습니다.
<br>
<br>

5.  현재 문자(***input**)가 unqouted state 이고 unexpension state 인데 redirection 일때
	- 의미 : rd_type 과 fd (0, 1)을 이용해 t_word(new)를 생성합니다.
<br>
<br>

6. 현재 문자(***input**)가 unqouted 이면서 공백 (' ') 일때
	- new word
<br>
<br>

7. 현재 문자(***input**)가 첫번째 캐릭터가 아닐때 (앞에서 단어가 이어지고 있을때)
	- word에 문자 추가
<br>
<br>

8. (new)word의 첫번째 character가 결정되지 않았고, 현재 문자(***input**)가 # 일때
	-  주석처리
<br>
<br>

9. 그 외에는 새로운 단어(new word)의 첫번째 캐릭터로 간주합니다.
<br>
<br>
</details>


토큰 종류
1. Commands
2. Redirection : < << >> >
3. Pipe : |
4. env : $
5. quotes : " '
